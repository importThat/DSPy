import numpy as np
from dsproc.sig import plot
from time import time
import os
from scipy.io.wavfile import write
from scipy import signal


class Signal:
    def __init__(self, fs, message, sps=2, amplitude=1, f=100):
        # Sampling frequency
        self.fs = fs
        # Message as an array of symbols
        self.message = message
        # Samples per symbol
        self.sps = sps
        # Intermediate frequency
        self.f = f
        # Mas amplitude of signal
        self.amp = amplitude

        self.samples = None
        self.fsk = False

    @property
    def dur(self):
        return self.sps * len(self.message) / self.fs

    @property
    def M(self):
        return len(np.unique(self.message))  # The number of symbols

    @property
    def t(self):
        return 1 / self.fs * np.arange(self.dur * self.fs)

    def create_samples(self, freq, theta=0, amp=1):
        """
        Signal = A * np.cos(2 * np.pi * f * t + theta) + A * 1j * np.sin(2 * np.pi * f * t + theta)
        where:
            A = amplitude
            f = frequency
            t = a time vector of the times samples are taken
            theta = a phase offset

            (j is the programming term for i, the complex number)
        """
        z = np.ndarray([])
        # Create a copy of t, because we may need to alter it
        t = self.t.copy()

        # If we're supplying a frequency vector (for FSK) then the length might not be compatible with t
        if type(freq) == np.ndarray:
            t = t[0:len(freq)]

        # Same for phase
        if type(theta) == np.ndarray:
            t = t[0:len(theta)]

        # same for amplitude
        if type(amp) == np.ndarray:
            t = t[0:len(amp)]

        # If there's no frequency (for example we just want to do a phase offset)
        if freq is int:
            if freq == 0:
                z = amp * np.cos(theta) + 1j * amp * np.sin(theta)

        else:
            angle = 2 * np.pi * freq * t + theta

            # equivalent to z = amp * np.exp(1j * (2 * np.pi * freq * t + theta))
            # but this way is faster
            z = amp * np.cos(angle) + 1j * amp * np.sin(angle)

        z = z.astype(np.complex64)

        return z

    def baseband(self):
        """
        Move the sig to baseband (0 frequency)
        """
        if not self.f:
            raise ValueError("Cannot baseband signal because the center frequency is unknown. Set the attribute 'f' to "
                             "some integer value")
        if self.fsk:
            freq = (np.arange(self.M) + 1) / self.M
            freq = np.mean(freq * self.f)

            offset = self.create_samples(freq=-1*freq)
        else:
            offset = self.create_samples(freq=-1*self.f)
        self.samples = self.samples * offset
        self.f = 0

    def phase_offset(self, angle=40):
        """
        Adds a phase offset of x degrees to the sig
        """
        # degrees to radians
        phase_offset = angle*np.pi / 180
        z = 1 * np.cos(phase_offset) + 1j * np.sin(phase_offset)

        self.samples = self.samples * z

    def freq_offset(self, freq=1000):
        """
        Moves the sig up by some amount of Hz
        """
        freq_offset = self.create_samples(freq=freq, theta=0, amp=1)
        freq_offset = freq_offset[0:len(self.samples)]  # In case it's a bit longer

        self.samples = self.samples * freq_offset
        if self.f:
            self.f += freq
        else:
            self.f = freq

        self.fsk = False

    def resample(self, up=16, down=1):
        """
        A simple wrapper for scipy's resample
        """
        self.samples = signal.resample_poly(self.samples, up, down)
        self.fs = int(self.fs * up/down)

    def efficiency(self):
        """
        Calculates bandwidth efficiency of the signal. This is the total area under the curve of the signals fft plot
        """
        ft = np.abs(np.fft.fft(self.samples))
        integral = np.sum(ft)
        return integral

    def power_spill(self, band_low, band_high):
        """
        Returns the power of the signal that lies outside the given bands. Use this when looking at the harmonics being
        generated by a signal
        """
        sos = signal.butter(10, (band_low, band_high), "bandstop", fs=self.fs, output="sos")
        filtered = signal.sosfilt(sos, self.samples)
        power = np.sum(np.abs(filtered))
        return power

    def highpass(self, f):
        """
        Applies a high pass filter at the given frequency. A high pass filter removes frequencies below the given level
        and allows frequencies above the given level through.
        """
        sos = signal.butter(10, f, 'highpass', fs=self.fs, output='sos')
        self.samples = signal.sosfilt(sos, self.samples)

    def lowpass(self, f):
        """
        Applies a low pass filter at the given frequency. A low pass filter removes frequencies above the given level
        and allows frequencies below the given level through.
        """
        sos = signal.butter(10, f, 'lowpass', fs=self.fs, output='sos')
        self.samples = signal.sosfilt(sos, self.samples)

    def bandpass(self, f_low, f_high):
        """
        Applies a bandpass filter around the given frequencies. This filter removes frequencies below f_low and above
        f_high, only returning those in the given band.
        """
        sos = signal.butter(10, (f_low, f_high), 'bandpass', fs=self.fs, output='sos')
        self.samples = signal.sosfilt(sos, self.samples)

    def bandstop(self, f_low, f_high):
        """
        Applies a bandstop filter between the given frequencies. This filter removes frequencies between f_low
        and f_high.
        """
        sos = signal.butter(10, (f_low, f_high), 'bandstop', fs=self.fs, output='sos')
        self.samples = signal.sosfilt(sos, self.samples)


    # ***********************************                    ************************************
    # ************************************ Plotting Functions ************************************
    # *************************************                    ************************************

    def phase_view(self, n=4000000, start_sample=0):
        """
        Plots the instantaneous phase of the signal
        """
        kwargs = {
            "type": "view",
            "subtype": "phase"
            }
        plot.plot(self.samples[start_sample:start_sample+n], **kwargs)

    def freq_view(self, n=4000000, start_sample=0):
        """
        Plots the instantaneous frequency of the signal
        """
        kwargs = {
            "type": "view",
            "subtype": "freq",
            "fs": self.fs
            }
        plot.plot(self.samples[start_sample:start_sample+n], **kwargs)

    def amp_view(self, n=4000000, start_sample=0):
        """
        Plots the instantaneous amplitude of the signal
        """
        kwargs = {
            "type": "view",
            "subtype": "amp"
            }
        plot.plot(self.samples[start_sample:start_sample+n], **kwargs)

    def specgram(self, nfft=1024):
        # Nfft shouldn't be bigger than the samples
        if nfft >= len(self.samples):
            nfft = int(len(self.samples)/4)

        kwargs = {"type": "specgram",
                "nfft": nfft,
                "fs": self.fs,
                "title": f"Specgram at Baseband (NFFT={nfft})"}

        plot.plot(self.samples, **kwargs)

    def psd(self, nfft=1024):
        kwargs = {"type": "psd",
                  "nfft": nfft,
                  "fs": self.fs,
                  "title": f"PSD at Baseband (NFFT={nfft})"}
        plot.plot(self.samples, **kwargs)

    def iq(self):
        kwargs = {"type": "iq",
                  "title": "IQ Scatter"}

        plot.plot(self.samples, **kwargs)

    def fft(self, nfft=1024):
        kwargs = {"type": "fft",
                  "title": "FFT of Signal",
                  "fs": self.fs,
                  "nfft":nfft}
        plot.plot(self.samples, **kwargs)

    def time(self, n=0):
        t = self.t
        t = t[0:len(self.samples)]

        kwargs = {"type": "time",
                  "t": t,
                  "title": "Time Domain",
                  "n": n}

        plot.plot(self.samples, **kwargs)

    def save(self, fn=None, path=None, wav=False):
        # TODO
        #  Make this path better
        # If there is no path provided then provide one
        if not path:
            path = os.getcwd()
            path = path.split("\\")     # I don't think this will work on non-windows?
            dspy_index = path.index("dsproc")
            path = '\\'.join(path[0:dspy_index+1]) + "\\" + "modulations"

        # If no file name make one
        if not fn:
            fn = f"Sig_f={self.f}_fs={self.fs}_dur={self.dur}_{int(time())}"

        save_string = path + "\\" + fn


        # If we're saving it as a wav
        if wav:
            if self.f == 0:
                self.freq_offset(800)

            audio = self.samples.real
            # Target sample rate
            sample_rate = 44100
            audio = signal.resample_poly(audio, up=sample_rate, down=self.fs)

            write(fn+".wave", sample_rate, audio.astype(np.float32))

            self.baseband()

        else:
            self.samples.tofile(save_string)



